//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================


// USER INCLUDES
#include <SI_C8051F990_Register_Enums.h>
#include "F99x_SMBus_Master.h"

//-----------------------------------------------------------------------------
// Global CONSTANTS
//-----------------------------------------------------------------------------

#define  SYSCLK         24500000       // System clock frequency in Hz


#define  SMB_FREQUENCY  10000          // Target SCL clock rate
// This example supports between 10kHz
// and 100kHz

#define  WRITE          0x00           // SMBus WRITE command
#define  READ           0x01           // SMBus READ command

#define ON           0             // Turns the LED on
#define OFF          1             // Turns the LED off


// Status vector - top 4 bits only
#define  SMB_MTSTA      0xE0           // (MT) start transmitted
#define  SMB_MTDB       0xC0           // (MT) data byte transmitted
#define  SMB_MRDB       0x80           // (MR) data byte received
volatile U8 ADDR_SEND ;
// End status vector definition

//-----------------------------------------------------------------------------
// SMBUS0_ISR
//-----------------------------------------------------------------------------
//
// SMBUS0 ISR Content goes here. Remember to clear flag bits:
// SMB0CN::SI (SMBus Interrupt Flag)
//
//-----------------------------------------------------------------------------
INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
{
	bit FAIL = 0;                       // Used by the ISR to flag failed
	// transfers
	// ADDR_SEND = 0;           // Used by the ISR to flag byte
	// transmissions as slave addresses

	if (SMB0CN_ARBLOST == 0)                   // Check for errors
	{
		// Normal operation
		switch (SMB0CN & 0xF0)           // Status vector
		{
			// Master Transmitter/Receiver: START condition transmitted.
		case SMB_MTSTA:
			//if(START_SMB){
			SMB0DAT = TARGET;          // Load address of the target slave
			SMB0DAT &= 0xFE;           // Clear the LSB of the address for the
			// R/W bit
			SMB0DAT |= SMB_RW;         // Load R/W bit
			SMB0CN_STA = 0;            // Manually clear START bit
			ADDR_SEND = 1;
			START_SMB=0;
			//}
			break;

			// Master Transmitter: Data byte transmitted
		case SMB_MTDB:
			if (SMB0CN_ACK)                   // Slave SMB0CN_ACK?
			{
				if (ADDR_SEND)          // If the previous byte was a slave
				{
					// UART_Send(ADDR_SEND);
					// UART_Send(ADDR_SEND);
					// Next byte is not a slave address

					if(CO2_MODE==1)
					{
						if (SMB_RW == WRITE) // If this transfer is a WRITE,
						{
							if(length>0){
							SMB0DAT=DATA_CO2_OUT[5-length];
							length--;
							}else{
								ADDR_SEND=0;
							}
						}
					}
					else if(CO2_MODE==0){
					if (SMB_RW == WRITE) // If this transfer is a WRITE,
					{
						// send data byte
						if(ADDR_SEND==1){
							SMB0DAT = SMB_REG_OUT;
						}
						if(ADDR_SEND==2){
							SMB0DAT = SMB_DATA_OUT;
						}

					}
					if(ADDR_SEND==1){
						ADDR_SEND = 2;
					}
					else if(ADDR_SEND==2){
						ADDR_SEND = 0;
						//UART_Send('x');
						//   	UART_Send('x');
					}
					if(RW_Reg==0){
						ADDR_SEND=0;
						//UART_Send('x');
					}

					else {}              // If this transfer is a READ,
					}
					// proceed with transfer without
					// writing to SMB0DAT (switch
					// to receive mode)
				}
				else                    // If previous byte was not a slave
				{                       // address,
					//UART_Send('x');
					if(RW_Reg==1)
					{
						SMB0CN_STO = 1;                   // Send STOP to terminate transfer
						SMB_BUSY = 0;              // Free SMBus interface
					}


				}
			}
			else                       // If slave NACK,
			{
				SMB0CN_STO = 1;                // Send STOP condition, followed
				SMB0CN_STA = 1;                // By a START
			}
			break;

			// Master Receiver: byte received
		case SMB_MRDB:
			if(CO2_MODE==2)
			{
				if(length>0)
				{
					if(length==2){
						DATA_CO2_IN = ((U16) SMB0DAT<<8);
					}else if (length==1){
						DATA_CO2_IN |= ((U16) SMB0DAT);
					}else{
						//SMB_DATA_IN=SMB0DAT;
					}
					SMB0CN_ACK = 1;
					length--;
				}else{
					            // Free SMBus interface
					SMB0CN_ACK = 0;                   // Send NACK to indicate last byte
					SMB0CN_STO = 1;                   // Send STOP to terminate transfer
					SMB_BUSY = 0;
				}

			}else{
			SMB_DATA_IN = SMB0DAT;     // Store received byte
			SMB0CN_ACK = 0;                   // Send NACK to indicate last byte
			SMB0CN_STO = 1;                   // Send STOP to terminate transfer
			SMB_BUSY = 0;              // Free SMBus interface
			//UART_Send('a');
			//SMB0CN_STO = 1;             // Set SMB0CN_STO to terminate transfer
			//SMB_BUSY = 0;
			}
			break;

		default:
			FAIL = 1;                  // Indicate failed transfer
			// and handle at end of ISR
			break;

		} // end switch
	}
	else
	{
		// SMB0CN_ARBLOST = 1, error occurred... abort transmission
		FAIL = 1;
	} // end SMB0CN_ARBLOST if

	if (FAIL)                           // If the transfer failed,
	{
		SMB0CF &= ~0x80;                 // Reset communication
		SMB0CF |= 0x80;
		SMB0CN_STA = 0;
		SMB0CN_STO = 0;
		SMB0CN_ACK = 0;

		SMB_BUSY = 0;                    // Free SMBus

		FAIL = 0;
                // Indicate an error occurred
	}

	SMB0CN_SI = 0;                             // Clear interrupt flag
}


//-----------------------------------------------------------------------------
// TIMER3_ISR
//-----------------------------------------------------------------------------
//
// TIMER3 ISR Content goes here. Remember to clear flag bits:
// TMR3CN::TF3H (Timer # High Byte Overflow Flag)
// TMR3CN::TF3L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------
/*
INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
{
	SMB0CF &= ~0x80;                    // Disable SMBus
	SMB0CF |= 0x80;                     // Re-enable SMBus
	TMR3CN &= ~0x80;                    // Clear Timer3 interrupt-pending flag
	SMB0CN_STA = 0;
	SMB_BUSY = 0;                       // Free SMBus
}
*/



