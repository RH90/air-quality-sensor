C51 COMPILER V9.53.0.0   SMARTCLOCK                                                        04/29/2018 23:54:57 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE SMARTCLOCK
OBJECT MODULE PLACED IN .\src\SmaRTClock.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\Rilind\
                    -Desktop\System_project\Exam_Project\Exam_Project_2\F99x-98x_SleepMode_smaRTClockWake\src\SmaRTClock.c OMF2 SMALL DEBUG O
                    -BJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCD
                    -IR(C:/Users/Rilind/Desktop/System_project/Exam_Project/Exam_Project_2/F99x-98x_SleepMode_smaRTClockWake/inc;C:/SiliconLa
                    -bs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer
                    -/sdks/8051/v4.1.1//Device/C8051F990/inc) PRINT(.\src\SmaRTClock.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Sma
                    -RTClock.OBJ)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // SmaRTClock.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2014 Silicon Laboratories, Inc.
   5          // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   6          //
   7          // Program Description:
   8          //
   9          // Driver for the SmaRTClock peripheral.
  10          //
  11          // Target:         C8051F99x-C8051F98x
  12          // Tool chain:     Generic
  13          // Command Line:   None
  14          //
  15          // Release 1.0
  16          //    - Initial Revision (FB)
  17          //    - 19 MAY 2010
  18          //
  19          
  20          //-----------------------------------------------------------------------------
  21          // Includes
  22          //-----------------------------------------------------------------------------
  23          #include "SI_C8051F990_Register_Enums.h"
  24          #include "C8051F990_lib.h"
  25          
  26          #if SMARTCLOCK_ENABLED
  27          
  28          //-----------------------------------------------------------------------------
  29          // Global Variables
  30          //-----------------------------------------------------------------------------
  31          
  32          // Variables used for the RTC interface
  33          U8 RTC0CN_Local;                       // Holds the desired RTC0CN settings
  34           
  35          //-----------------------------------------------------------------------------
  36          // Global CONSTANTS
  37          //-----------------------------------------------------------------------------
  38          
  39          //-----------------------------------------------------------------------------
  40          // Function PROTOTYPES
  41          //-----------------------------------------------------------------------------
  42          
  43          U8   RTC_Read (U8 reg);
  44          void RTC_Write (U8 reg, U8 value);
  45          void RTC_WriteAlarm (U32 alarm);
  46          U32  RTC_GetCurrentTime(void);
  47          void RTC_SetCurrentTime(U32 time);
  48          void RTC0CN_SetBits(U8 bits);
  49          void RTC0CN_ClearBits(U8 bits);
  50          void RTC_SleepTicks(U32 ticks);
C51 COMPILER V9.53.0.0   SMARTCLOCK                                                        04/29/2018 23:54:57 PAGE 2   

  51          
  52          //-----------------------------------------------------------------------------
  53          // RTC_Read ()
  54          //-----------------------------------------------------------------------------
  55          //
  56          // Return Value : RTC0DAT
  57          // Parameters   : 1) U8 reg - address of RTC register to read
  58          //
  59          // This function will read one byte from the specified RTC register.
  60          // Using a register number greater that 0x0F is not permited.
  61          //
  62          //  Timing of SmaRTClock register read with short bit set
  63          //
  64          //     mov      RTC0ADR, #094h
  65          //     nop
  66          //     nop
  67          //     nop
  68          //     mov      A, RTC0DAT
  69          //
  70          //-----------------------------------------------------------------------------
  71          U8 RTC_Read (U8 reg)
  72          {
  73   1      
  74   1         RTC0ADR  = (0x90 | reg);            // pick register and set BUSY to 
  75   1                                             // initiate the read
  76   1                                    
  77   1         NOP(); NOP(); NOP();                // delay 3 system clocks
  78   1         
  79   1         return RTC0DAT;                     // return value
  80   1      }
  81          
  82          //-----------------------------------------------------------------------------
  83          // RTC_Write ()
  84          //-----------------------------------------------------------------------------
  85          //
  86          // Return Value : none
  87          // Parameters   : 1) U8 reg - address of RTC register to write
  88          //                2) U8 value - the value to write to <reg>
  89          //
  90          // This function will Write one byte to the specified RTC register.
  91          // Using a register number greater that 0x0F is not permited.
  92          //
  93          // Timing of SmaRTClock register write with short bit set
  94          //
  95          //       mov      RTC0ADR, #014h
  96          //       mov      RTC0DAT, #088h
  97          //       nop
  98          //
  99          //-----------------------------------------------------------------------------
 100          void RTC_Write (U8 reg, U8 value)
 101          {
 102   1         RTC0ADR  = (0x10 | reg);            // pick register
 103   1         RTC0DAT = value;                    // write data
 104   1      }
 105          
 106          //-----------------------------------------------------------------------------
 107          // RTC_WriteAlarm ()
 108          //-----------------------------------------------------------------------------
 109          //
 110          // Return Value : none
 111          // Parameters   : 1) U32 alarm - the value to write to <ALARM>
 112          //
 113          // This function writes a value to the <ALRM> registers
C51 COMPILER V9.53.0.0   SMARTCLOCK                                                        04/29/2018 23:54:57 PAGE 3   

 114          //
 115          // Instruction timing of multi-byte write with short bit set
 116          //
 117          //       mov      RTC0ADR, #010h
 118          //       mov      RTC0DAT, #05h
 119          //       nop
 120          //       mov      RTC0DAT, #06h
 121          //       nop
 122          //       mov      RTC0DAT, #07h
 123          //       nop
 124          //       mov      RTC0DAT, #08h
 125          //       nop
 126          //
 127          //-----------------------------------------------------------------------------
 128          
 129          void RTC_WriteAlarm (U32 alarm)
 130          {   
 131   1         UU32 alarm_value;
 132   1      
 133   1         alarm_value.U32 = alarm;   
 134   1      
 135   1         // Temporarily disable alarm while updating registers
 136   1         RTC0ADR = (0x10 | RTC0CN);
 137   1         RTC0DAT = (RTC0CN_Local & ~RTC0AEN);       
 138   1         NOP();
 139   1         
 140   1         // Write the value to the alarm registers
 141   1         RTC0ADR = (0x10 | ALARM0);       
 142   1         RTC0DAT = alarm_value.U8[b0];    // write data
 143   1         NOP();
 144   1         RTC0DAT = alarm_value.U8[b1];    // write data
 145   1         NOP();
 146   1         RTC0DAT = alarm_value.U8[b2];    // write data
 147   1         NOP(); 
 148   1         RTC0DAT = alarm_value.U8[b3];    // write data
 149   1         NOP(); 
 150   1         
 151   1         // Restore alarm state after registers have been written
 152   1         RTC0ADR = (0x10 | RTC0CN);
 153   1         RTC0DAT = RTC0CN_Local;  
 154   1      }
 155          
 156          //-----------------------------------------------------------------------------
 157          // RTC_GetCurrentTime()
 158          //-----------------------------------------------------------------------------
 159          //
 160          // Return Value : U32 value - the value of the SmaRTClock
 161          // Parameters   : none
 162          //
 163          // This function reads the current value of the SmaRTClock
 164          //
 165          // Instruction timing of multi-byte read with short bit set
 166          //
 167          //       mov      RTC0ADR, #0d0h
 168          //       nop
 169          //       nop
 170          //       nop
 171          //       mov      A, RTC0DAT
 172          //       nop
 173          //       nop
 174          //       mov      A, RTC0DAT
 175          //       nop
 176          //       nop
C51 COMPILER V9.53.0.0   SMARTCLOCK                                                        04/29/2018 23:54:57 PAGE 4   

 177          //       mov      A, RTC0DAT
 178          //       nop
 179          //       nop
 180          //       mov      A, RTC0DAT
 181          //
 182          //-----------------------------------------------------------------------------
 183          U32 RTC_GetCurrentTime(void)
 184          {
 185   1         UU32 current_time;   
 186   1      
 187   1         RTC_Write( RTC0CN, RTC0CN_Local | RTC0CAP);   // Write '1' to RTC0CAP   
 188   1         while((RTC_Read(RTC0CN) & RTC0CAP));          // Wait for RTC0CAP -> 0
 189   1         
 190   1         RTC0ADR = (0xD0 | CAPTURE0);
 191   1         NOP(); NOP(); NOP();
 192   1         current_time.U8[b0] = RTC0DAT;               // Least significant byte
 193   1         NOP(); NOP();
 194   1         current_time.U8[b1] = RTC0DAT;
 195   1         NOP(); NOP();
 196   1         current_time.U8[b2] = RTC0DAT;
 197   1         NOP(); NOP();
 198   1         current_time.U8[b3] = RTC0DAT;               // Most significant byte
 199   1         
 200   1         return current_time.U32;
 201   1      
 202   1      }
 203          
 204          //-----------------------------------------------------------------------------
 205          // RTC_SetCurrentTime()
 206          //-----------------------------------------------------------------------------
 207          //
 208          // Return Value : none 
 209          // Parameters   : 
 210          //
 211          // This function sets the current value of the SmaRTClock
 212          //
 213          // Instruction timing of multi-byte write with short bit set
 214          //
 215          //       mov      RTC0ADR, #010h
 216          //       mov      RTC0DAT, #05h
 217          //       nop
 218          //       mov      RTC0DAT, #06h
 219          //       nop
 220          //       mov      RTC0DAT, #07h
 221          //       nop
 222          //       mov      RTC0DAT, #08h
 223          //       nop
 224          
 225          //-----------------------------------------------------------------------------
 226          void RTC_SetCurrentTime(U32 time)
 227          {
 228   1         UU32 current_time;
 229   1         
 230   1         current_time.U32 = time;
 231   1      
 232   1         // Write the time to the capture registers
 233   1         RTC0ADR = (0x10 | CAPTURE0);       
 234   1         RTC0DAT = current_time.U8[b0];    // write data
 235   1         NOP();
 236   1         RTC0DAT = current_time.U8[b1];    // write data
 237   1         NOP();
 238   1         RTC0DAT = current_time.U8[b2];    // write data
 239   1         NOP(); 
C51 COMPILER V9.53.0.0   SMARTCLOCK                                                        04/29/2018 23:54:57 PAGE 5   

 240   1         RTC0DAT = current_time.U8[b3];    // write data
 241   1         NOP(); 
 242   1       
 243   1         RTC_Write( RTC0CN, RTC0CN_Local | RTC0SET);   // Write '1' to RTC0SET   
 244   1         while((RTC_Read(RTC0CN) & RTC0SET));          // Wait for RTC0SET -> 0
 245   1      
 246   1      }
 247          
 248          //-----------------------------------------------------------------------------
 249          // RTC0CN_SetBits()
 250          //-----------------------------------------------------------------------------
 251          //
 252          // Return Value : none 
 253          // Parameters   : 
 254          //
 255          // This function sets bits in the RTC0CN register
 256          //-----------------------------------------------------------------------------
 257          void RTC0CN_SetBits(U8 bits)
 258          {
 259   1         RTC0CN_Local |= (bits & ~0x03);
 260   1         RTC_Write( RTC0CN, RTC0CN_Local | bits);
 261   1      }
 262          
 263          //-----------------------------------------------------------------------------
 264          // RTC0CN_ClearBits()
 265          //-----------------------------------------------------------------------------
 266          //
 267          // Return Value : none 
 268          // Parameters   : 
 269          //
 270          // This function clears bits in the RTC0CN register
 271          //-----------------------------------------------------------------------------
 272          void RTC0CN_ClearBits(U8 bits)
 273          {
 274   1         RTC0CN_Local &= bits;
 275   1         RTC_Write( RTC0CN, RTC0CN_Local);
 276   1      }    
 277          
 278          /*
 279          //-----------------------------------------------------------------------------
 280          // RTC_SleepTicks
 281          //-----------------------------------------------------------------------------
 282          //
 283          // Return Value : none
 284          // Parameters   : 1) U32 the number of ticks to Sleep
 285          //
 286          // This function sleeps for the specified number of RTC ticks.  This function
 287          // is commented out and has been replaced by a simplified version below which
 288          // does not check for a "wrap" condition.  The simplified version of this
 289          // function cannot be used asynchronously with another "sleep" process,
 290          // however, this version may be used asynchronously at the expense of 
 291          // increased code space and execution time.
 292          // 
 293          // Note: The minimum number of ticks is 3
 294          //
 295          // Note: This routine will exit if a pre-configured RTC Alarm occurs, or if
 296          // another wake-up source occurs.
 297          // 
 298          //-----------------------------------------------------------------------------
 299          
 300          void RTC_SleepTicks(U32 ticks)
 301          {
 302             U8 EA_save;
C51 COMPILER V9.53.0.0   SMARTCLOCK                                                        04/29/2018 23:54:57 PAGE 6   

 303             U8 PMU0CF_save;
 304             U8 RTC0CN_save;
 305          
 306             UU32 current_time;
 307             UU32 current_alarm;
 308             UU32 alarm_value;
 309             
 310             U8 pending_alarm;
 311             U8 alarm_wrap;  
 312             
 313             // Disable Interrupts
 314             EA_save = IE_EA;
 315             IE_EA = 0;
 316             
 317             // Check for pending alarms
 318             pending_alarm = RTC_Alarm;
 319          
 320             // Initiate Capture of the current time 
 321             RTC_Write( RTC0CN, RTC0CN_Local | RTC0CAP);   // Write '1' to RTC0CAP   
 322             
 323             // Read the current alarm value
 324             RTC0ADR = (0xD0 | ALARM0);
 325             NOP(); NOP(); NOP();
 326             current_alarm.U8[b0] = RTC0DAT;               // Least significant byte
 327             NOP(); NOP();
 328             current_alarm.U8[b1] = RTC0DAT;
 329             NOP(); NOP();
 330             current_alarm.U8[b2] = RTC0DAT;
 331             NOP(); NOP();
 332             current_alarm.U8[b3] = RTC0DAT;               // Most significant byte
 333             
 334             // Copy the current time into <current_time>
 335             while((RTC_Read(RTC0CN) & RTC0CAP));         // Wait for RTC0CAP -> 0
 336             RTC0ADR = (0xD0 | CAPTURE0);
 337             NOP(); NOP(); NOP();
 338             current_time.U8[b0] = RTC0DAT;               // Least significant byte
 339             NOP(); NOP();
 340             current_time.U8[b1] = RTC0DAT;
 341             NOP(); NOP();
 342             current_time.U8[b2] = RTC0DAT;
 343             NOP(); NOP();
 344             current_time.U8[b3] = RTC0DAT;               // Most significant byte
 345          
 346             // Preserve RTC0CN
 347             RTC0CN_save = RTC0CN_Local;
 348          
 349             // Check for wrap if alarm is enabled
 350             if((RTC0CN_Local & RTC0AEN) && (current_time.U32 + ticks > current_alarm.U32))
 351             {  
 352                alarm_value.U32 = current_alarm.U32;
 353                alarm_wrap = 1;
 354          
 355             } else
 356             {
 357                alarm_value.U32 = current_time.U32 + ticks;
 358                RTC0CN_Local &= ~ALRM;
 359                alarm_wrap = 0;
 360             }
 361                    
 362             // Write the alarm value
 363             RTC_WriteAlarm(alarm_value.U32);   
 364          
 365             // Force the RTC wake-up sources to be enabled
C51 COMPILER V9.53.0.0   SMARTCLOCK                                                        04/29/2018 23:54:57 PAGE 7   

 366             PMU0CF_save = PMU0CF_Local;
 367             PMU0CF_Local |= RTC;
 368             
 369             // Place device in Sleep Mode
 370             LPM(SLEEP);
 371          
 372             // Restore Enabled Wake-up Sources and RTC state
 373             PMU0CF_Local = PMU0CF_save;
 374             RTC0CN_Local = RTC0CN_save;   
 375          
 376             // Clear Alarm Flag unless a wrap was detected or it was already
 377             // set upon entry into the function
 378             if(alarm_wrap == 0 && pending_alarm == 0)
 379             {
 380                RTC_Alarm = 0;
 381             }
 382          
 383             // Restore alarm value unless a wrap was detected
 384             if(alarm_wrap == 0)
 385             {
 386                RTC_WriteAlarm(current_alarm.U32);
 387             }  
 388             
 389             // Restore Interrupts
 390             IE_EA = EA_save;
 391          
 392          }   
 393          
 394          */
 395          
 396          //-----------------------------------------------------------------------------
 397          // RTC_SleepTicks
 398          //-----------------------------------------------------------------------------
 399          //
 400          // Return Value : none
 401          // Parameters   : 1) U32 the number of ticks to Sleep
 402          //
 403          // This function sleeps for the specified number of RTC ticks.  Software should
 404          // ensure that the device will wake up and restore the original RTC alarm 
 405          // value before the next alarm occurs. 
 406          // 
 407          // Note: The minimum number of ticks is 3
 408          //
 409          // 
 410          //-----------------------------------------------------------------------------
 411          
 412          void RTC_SleepTicks(U32 ticks)
 413          {
 414   1         U8 EA_save;
 415   1         U8 PMU0CF_save;
 416   1         U8 RTC0CN_save;
 417   1      
 418   1         UU32 current_time;
 419   1         
 420   1         // Disable Interrupts
 421   1         EA_save = IE_EA;
 422   1         IE_EA = 0;
 423   1      
 424   1         // Preserve RTC0CN
 425   1         RTC0CN_save = RTC0CN_Local;
 426   1         
 427   1         // Disable Auto Reset
 428   1         RTC0CN_ClearBits(~ALRM);
C51 COMPILER V9.53.0.0   SMARTCLOCK                                                        04/29/2018 23:54:57 PAGE 8   

 429   1      
 430   1         // Obtain the current time
 431   1         current_time.U32 = RTC_GetCurrentTime();
 432   1                    
 433   1         // Write the alarm value
 434   1         RTC_WriteAlarm(current_time.U32 + ticks);   
 435   1      
 436   1         // Force the RTC wake-up sources to be enabled
 437   1         PMU0CF_save = PMU0CF_Local;
 438   1         PMU0CF_Local |= RTC;
 439   1         
 440   1         // Place device in Sleep Mode
 441   1         LPM(SLEEP);
 442   1      
 443   1         // Restore Enabled Wake-up Sources and RTC state
 444   1         PMU0CF_Local = PMU0CF_save;
 445   1         RTC0CN_Local = RTC0CN_save;   
 446   1      
 447   1         // Clear Alarm Flag
 448   1         RTC_Alarm = 0;
 449   1      
 450   1         // Restore alarm value unless a wrap was detected
 451   1         RTC_WriteAlarm(WAKE_INTERVAL_TICKS);
 452   1         
 453   1         // Restore Interrupts
 454   1         IE_EA = EA_save;
 455   1      
 456   1      }
 457          
 458          #endif       


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    279    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      23
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
